// tests/skip.test.ts
import {describe, it, expect, beforeEach, afterEach} from 'vitest';
import fs from 'fs-extra';
import path from 'path';
import {useTempProject} from "./helpers/use-temp-project";
import {generateBarrels} from "../src";

const SKIP_FILENAME = 'skip-file.ts';

describe('skip', () => {
    let cleanup: () => Promise<void>;
    let tmpDir: string;

    beforeEach(async () => {
        // useTempProject already handles cwd change and cleanup
        const temp = await useTempProject('basic-project', 'config');
        cleanup = temp.cleanup;
        tmpDir = temp.tmp;
    });

    afterEach(async () => {
        await cleanup();
    });
    describe('Skip comment', () => {
        it('should not overwrite barrel with skip comment while generating all barrels', async () => {
            const skipFile = path.join(tmpDir, 'src', 'features', 'skip', SKIP_FILENAME);
            await fs.writeFile(skipFile, '// @libria/ts-barrels skip\nexport * from "./c";');

            await generateBarrels(path.join(tmpDir, 'src'), {all: true, force: false, filename: SKIP_FILENAME});

            // Skip file should not be overwritten
            const skipContent = await fs.readFile(skipFile, 'utf-8');
            expect(skipContent).toContain('@libria/ts-barrels skip');
            expect(skipContent).toContain('export * from "./c"');

            // Other barrels should be generated
            const featuresBarrel = path.join(tmpDir, 'src', 'features', SKIP_FILENAME);
            const srcBarrel = path.join(tmpDir, 'src', SKIP_FILENAME);

            expect(await fs.pathExists(featuresBarrel)).toBe(true);
            expect(await fs.pathExists(srcBarrel)).toBe(true);

            // Features barrel should re-export from skip
            const featuresContent = await fs.readFile(featuresBarrel, 'utf-8');
            expect(featuresContent).toContain(`export * from './skip/${SKIP_FILENAME.replace('.ts', '')}'`);

            // Src barrel should re-export from features
            const srcContent = await fs.readFile(srcBarrel, 'utf-8');
            expect(srcContent).toContain(`export * from './features/${SKIP_FILENAME.replace('.ts', '')}'`);
        });

        it('should preserve skip comment even with force option', async () => {
            const skipFile = path.join(tmpDir, 'src', 'features', 'skip', SKIP_FILENAME);
            const customExport = 'export * from "./c";\nexport const custom = true;';
            await fs.writeFile(skipFile, `// @libria/ts-barrels skip\n${customExport}`);

            // Run with force: true
            await generateBarrels(path.join(tmpDir, 'src'), {all: true, force: true, filename: SKIP_FILENAME});

            // Skip file should still not be overwritten even with force
            const skipContent = await fs.readFile(skipFile, 'utf-8');
            expect(skipContent).toContain('@libria/ts-barrels skip');
            expect(skipContent).toContain('export const custom = true');
        });

        it('should overwrite existing barrels without skip comment when force is true', async () => {
            // Create an existing barrel without skip comment
            const existingBarrel = path.join(tmpDir, 'src', 'features', SKIP_FILENAME);
            await fs.writeFile(existingBarrel, '// Old content\nexport const old = true;');

            // Run with force: true
            await generateBarrels(path.join(tmpDir, 'src'), {all: true, force: true, filename: SKIP_FILENAME});

            // Barrel should be overwritten
            const content = await fs.readFile(existingBarrel, 'utf-8');
            expect(content).toContain('// Generated by @libria/ts-barrels');
            expect(content).not.toContain('export const old = true');
        });

        it('should not overwrite existing barrels without skip comment when force is false', async () => {
            // Create an existing barrel without skip comment
            const existingBarrel = path.join(tmpDir, 'src', 'features', SKIP_FILENAME);
            await fs.writeFile(existingBarrel, '// Old content\nexport const old = true;');

            // Run with force: false
            await generateBarrels(path.join(tmpDir, 'src'), {all: true, force: false, filename: SKIP_FILENAME});

            // Barrel should NOT be overwritten
            const content = await fs.readFile(existingBarrel, 'utf-8');
            expect(content).toContain('export const old = true');
            expect(content).not.toContain('// Generated by @libria/ts-barrels');
        });
    });
});
