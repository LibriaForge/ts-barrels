import path from 'path';

import fs from 'fs-extra';

export interface BarrelOptions {
    all: boolean;
    force: boolean;
    filename: string;
}

export async function generateBarrels(folder: string, options: BarrelOptions): Promise<string | null> {
    // 0️⃣ Check for .lbbign marker file - if present, skip this folder entirely
    const ignoreFilePath = path.join(folder, '.lbbign');
    if (await fs.pathExists(ignoreFilePath)) {
        console.log(`⏭ Ignoring ${folder} (.lbbign file found)`);
        return null;
    }

    // 1️⃣ List all subfolders
    const entries = await fs.readdir(folder);
    const subdirs: string[] = [];
    const localFiles: string[] = [];

    for (const entry of entries) {
        const fullPath = path.join(folder, entry);
        const stat = await fs.stat(fullPath);
        if (stat.isDirectory()) {
            subdirs.push(fullPath);
        } else if (stat.isFile() && entry.endsWith('.ts') && entry !== options.filename) {
            localFiles.push(entry.replace(/\.ts$/, ''));
        }
    }

    // 2️⃣ Process subfolders: generate if --all, otherwise check for existing barrels
    const childBarrels: string[] = [];
    for (const subdir of subdirs) {
        if (options.all) {
            const child = await generateBarrels(subdir, options);
            if (child) childBarrels.push(child);
        } else {
            // Check if subdirectory already has a barrel file
            const subBarrelPath = path.join(subdir, options.filename);
            if (await fs.pathExists(subBarrelPath)) {
                childBarrels.push(subBarrelPath);
            }
        }
    }

    // 3️⃣ Determine barrel file path
    const barrelPath = path.join(folder, options.filename);

    // 4️⃣ Check existing file
    if (await fs.pathExists(barrelPath)) {
        const content = await fs.readFile(barrelPath, 'utf-8');
        // Always respect skip comment, even with --force
        if (/@libria\/ts-barrels skip/.test(content)) {
            console.log(`⏭ Skipping ${barrelPath} (skip comment)`);
            return barrelPath; // still return path for parent aggregation
        }
        // If file exists and no --force, skip generation
        if (!options.force) {
            console.log(`⏭ Skipping ${barrelPath} (already exists, use --force to overwrite)`);
            return barrelPath;
        }
    }

    // 5️⃣ Build export statements
    const exports: string[] = [];

    // Child barrels
    childBarrels.forEach(childPath => {
        let relative = path.relative(folder, childPath).replace(/\\/g, '/');
        // Remove .ts extension
        relative = relative.replace(/\.ts$/, '');
        // If it's index.ts, just use the directory name (TypeScript resolves index automatically)
        const barrelBasename = path.basename(options.filename, '.ts');
        if (barrelBasename === 'index') {
            relative = path.dirname(relative);
        }
        exports.push(`export * from './${relative}';`);
    });

    // Local files
    localFiles.forEach(f => exports.push(`export * from './${f}';`));

    if (exports.length === 0) {
        console.log(`⚠ No exports for ${barrelPath}, skipping generation`);
        return barrelPath;
    }

    const barrelContent = `// Generated by @libria/ts-barrels
${exports.join('\n')}
`;

    await fs.writeFile(barrelPath, barrelContent, 'utf-8');
    console.log(`✅ Generated barrel: ${barrelPath}`);

    return barrelPath;
}
